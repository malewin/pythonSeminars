# Задача 12: Петя и Катя – брат и сестра. Петя – студент, а Катя –  школьница. Петя помогает Кате по математике. Он задумывает два
#  натуральных числа X и Y (X,Y≤1000), а Катя должна их отгадать. Для этого Петя делает две подсказки. Он называет сумму этих чисел S и их
#  произведение P. Помогите Кате отгадать задуманные Петей числа.
# 4 4 -> 2 2 
# 5 6 -> 2 3

# надо разбить сумму на все возможные уникальные составляющие через цикл пока не вылетит (в каждой иттерации отнимать от суммы слагаемое x повышая иттерационно на 1), 
# составить множество, и так же с умножением (только в каждой иттерации делить целочисленно на х если это возможно и заносить в элемент множества), потом найти пересечения множеств.

p = abs(int(input("Брат, скажи произведение чисел, брат: ")))
s = abs(int(input("Брат, сумму их еще подскажи по-брацки а: ")))
slagaemye = set()  # задаём множества
mnozhiteli = set()
result = set ()
buffer = []
x = 1 # предполагаем начать подбор с 1, так как с 0 нет смысла
y = s - x # лучше не подставлять эту переменную в функцию добавления элемента (из-за обращений туда сюда и недоработок - будет выдавать просто set() вместо множества с элементами)

def setSetSlag():
    global s # чтоб внутри функции компилятор понимал что работает не с внутренней переменной а с внешней
    global x
    flag = 0  # локальная вспомогатльная переменная для обрыва цикла while
    while (flag == 0):
        if (s <= 2000 and s > 1 and x < s):
            for i in range(s):
                temp = slagaemye.add(s-x)
                x += 1
            flag = 1             
            return slagaemye  # возвращаем функции заполненное множество слагаемых
        else:
            print('что-то не так, брат, проверь какую сумму ввёл')
            s = int(input("Брат, сумму их еще по-брацки а: "))

def setSetMnozh():
    global p
    global x
    x = 1
    flag = 0  # локальная вспомогатльная переменная для обрыва цикла while
    while (flag == 0):
        if (p <= 1000000 and p > 0):
            for i in range(p):
                if p // x:
                    temp = mnozhiteli.add(p // x)
                    x += 1
                else:
                    x += 1
            flag = 1
            return mnozhiteli  # возвращаем функции заполненное множество множителей
    else:
        print('что-то не так, брат, проверь какое произведение ввёл')
        p = int(input("Брат, скажи произведение чисел нормально, а: "))

print(f'множество возможных слагаемых судя по сумме: {setSetSlag()}')
print(f'множество возможных целочисленных множителей судя по произведению: {setSetMnozh()}')
result = slagaemye.intersection(mnozhiteli) # находим общие элементы множеств
print(f'круг сузился: {result}')

buffer = list(result) #конвертируем наше множество в список для работы с индексами

# def solutingMethod(list):
#     pair = () # задаём кортеж в котором вернём результат перебора
#     for i in list:
#         for j in list:
#             if((list[i] * list[j] == p) and (list[i] + list[j] == s)): #если при переборе одновременно попадутся такие элементы списка что будут выполняться эти условия
#                 pair = (list[i], list[j], ) # то мы запишем их в кортеж и вернём
#     return pair

# print(solutingMethod(buffer))

def solutingMethod(list):
    pair = () # задаём кортеж в котором вернём результат перебора
    i = 0
    while i < (len(list)):
        j = 0
        while j < (len(list)):
            if((list[i] * list[j] == p) and (list[i] + list[j] == s)): #если при переборе одновременно попадутся такие элементы списка что будут выполняться эти условия
                pair = (list[i], list[j], ) # то мы запишем их в кортеж и вернём
    return pair

print(solutingMethod(buffer))






        
   



