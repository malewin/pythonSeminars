# Задача 12: Петя и Катя – брат и сестра. Петя – студент, а Катя –  школьница. Петя помогает Кате по математике. Он задумывает два
#  натуральных числа X и Y (X,Y≤1000), а Катя должна их отгадать. Для этого Петя делает две подсказки. Он называет сумму этих чисел S и их
#  произведение P. Помогите Кате отгадать задуманные Петей числа.
# 4 4 -> 2 2 
# 5 6 -> 2 3

# надо разбить сумму на все возможные уникальные составляющие через цикл пока не вылетит (в каждой иттерации отнимать от суммы слагаемое x повышая иттерационно на 1), 
# составить множество, и так же с умножением (только в каждой иттерации делить целочисленно на х если это возможно и заносить в элемент множества), потом найти пересечения множеств.

p = abs(int(input("Брат, скажи произведение чисел, брат: ")))
s = abs(int(input("Брат, сумму их еще подскажи по-брацки а: ")))

def correctInput(int1, int2): # метод проверки на берегу чтоб сумма не была больше произведения
    while (int1 > int2):
        int1 = abs(int(input("Брат, сумму их еще подскажи по-брацки а: ")))
    return int1


slagaemye = set()  # задаём множество слагаемых
mnozhiteli = set() # множество
result = set () # множество пересечений элементов множеств
buffer = [] # задаём список в который позже конвертируем заполненное множество для работы с индексами
x = 1 # предполагаем начать подбор с 1, так как с 0 нет смысла
y = s - x # лучше не подставлять эту переменную в функцию добавления элемента (из-за обращений туда сюда и недоработок - будет выдавать просто set() вместо множества с элементами)

def setSetSlag():               # метод заполнения множества возможных слагаемых
    global s # чтоб внутри функции компилятор понимал что работает не с внутренней переменной а с внешней
    global x
    flag = 0  # локальная вспомогатльная переменная для обрыва цикла while
    while (flag == 0):
        if (s <= 2000 and s > 1 and x < s):
            for i in range(s):
                temp = slagaemye.add(s-x)
                x += 1
            flag = 1             
            return slagaemye  # возвращаем функции заполненное множество слагаемых
        else:
            print('что-то не так, брат, проверь какую сумму ввёл')
            s = int(input("Брат, сумму их еще по-брацки а: "))

def setSetMnozh():           # метод заполнения множества возможных множителей
    global p
    global x
    x = 1
    flag = 0  # локальная вспомогатльная переменная для обрыва цикла while
    while (flag == 0):
        if (p <= 1000000 and p > 0):
            for i in range(p):
                if p // x:
                    temp = mnozhiteli.add(p // x)
                    x += 1
                else:
                    x += 1
            flag = 1
            return mnozhiteli  # возвращаем функции заполненное множество множителей
    else:
        print('что-то не так, брат, проверь какое произведение ввёл')
        p = int(input("Брат, скажи произведение чисел нормально, а: "))

correctInput(s,p)
print(f'множество возможных слагаемых судя по сумме: {setSetSlag()}')
print(f'множество возможных целочисленных множителей судя по произведению: {setSetMnozh()}')
result = slagaemye.intersection(mnozhiteli) # находим общие элементы множеств
print(f'круг сузился: {result}')

buffer = list(result) #конвертируем наше множество в список для работы с индексами

def solutingMethod(list):           # метод перебирающий список сконвертированного множества и сравнивающий равны ли сумма элементов заданной сумме и произведение элементов данному произведению
    pair = () # задаём кортеж в котором вернём результат перебора
    for i in list:
        for j in list:
            if((i * j== p) and (i * j == s)): #если при переборе одновременно попадутся такие элементы списка что будут выполняться эти условия
                pair = (i, j , ) # то мы запишем их в кортеж и вернём
    return pair

print(f'Твоя пара чисел,брат,больше не подходи ко мне с такими глупостями, иди уже работай: {solutingMethod(buffer)}')








        
   



