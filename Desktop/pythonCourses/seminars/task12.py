
# from math import sqrt

# p = int(input("Брат, скажи произведение чисел, брат: "))
# s = int(input("Брат, сумму их еще по-брацки а: "))

# # y = s -x
# # p = x * (s - x)
# # x^2 - x*s + p == 0
# # d = s^2 - 4*p

# x1 = s - sqrt(s**2 - 4*p)
# x2 = s + sqrt(s**2 - 4*p)
# y1 = s - x1
# y2 = s - x2
# # if p == x1 * y1:
# print(f'это могут быть пары чисел {x1} и {y1} либо {x2} и {y2}')

# def eternity():
#     while True:
#         if s > 2000 or x > 1000 or y > 1000: 
#             return False
#         else:
#             temp = slagaemye.add(s - x)
#             x += 1


# Задача 12: Петя и Катя – брат и сестра. Петя – студент, а Катя –  школьница. Петя помогает Кате по математике. Он задумывает два
#  натуральных числа X и Y (X,Y≤1000), а Катя должна их отгадать. Для этого Петя делает две подсказки. Он называет сумму этих чисел S и их
#  произведение P. Помогите Кате отгадать задуманные Петей числа.
# 4 4 -> 2 2 
# 5 6 -> 2 3

# надо разбить сумму на все возможные уникальные составляющие через цикл пока не вылетит (в каждой иттерации отнимать от суммы слагаемое x повышая иттерационно на 1), 
# составить множество, и так же с умножением (только в каждой иттерации делить целочисленно на х если это возможно и заносить в элемент множества), потом найти пересечения множеств.

p = abs(int(input("Брат, скажи произведение чисел, брат: ")))
s = abs(int(input("Брат, сумму их еще по-брацки а: ")))
slagaemye = set()  # задаём множества
mnozhiteli = set()
result = set ()
x = 1 # предполагаем начать подбор с 1, так как с 0 нет смысла
y = s - x # лучше не подставлять эту переменную в функцию добавления элемента (из-за обращений туда сюда и недоработок - будет выдавать просто set() вместо множества с элементами)

def setSetSlag():
    global s # чтоб внутри функции компилятор понимал что работает не с внутренней переменной а с внешней
    global x
    flag = 0  # локальная вспомогатльная переменная для обрыва цикла while
    while (flag == 0):
        if (s <= 2000 and s > 1 and x < s):
            for i in range(s):
                temp = slagaemye.add(s-x)
                x += 1
            flag = 1             
            return slagaemye  # возвращаем функции заполненное множество слагаемых
        else:
            print('что-то не так, брат, проверь какую сумму ввёл')
            s = int(input("Брат, сумму их еще по-брацки а: "))

def setSetMnozh():
    global p
    global x
    x = 1
    flag = 0  # локальная вспомогатльная переменная для обрыва цикла while
    while (flag == 0):
        if (p <= 1000000 and p > 0):
            for i in range(p):
                if p // x:
                    temp = mnozhiteli.add(p // x)
                    x += 1
                else:
                    x += 1
            flag = 1
            return mnozhiteli  # возвращаем функции заполненное множество множителей
    else:
        print('что-то не так, брат, проверь какое произведение ввёл')
        p = int(input("Брат, скажи произведение чисел нормально, а: "))

print(f'множество возможных слагаемых судя по сумме: {setSetSlag()}')
print(f'множество возможных целочисленных множителей судя по произведению: {setSetMnozh()}')
result = slagaemye.intersection(mnozhiteli) # находим общие элементы множеств
print(f'круг сузился: {result}')

def solutingMethod(set):
    









        
   



